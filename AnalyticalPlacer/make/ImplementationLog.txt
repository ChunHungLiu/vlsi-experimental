2008-03-08-kirill
пытаемся разобраться, почему перед легализацией расположение элементов напоминает
кольцо. мое перове предположение было, что элементы распространятся по плате 
такой волной, вытягивая за собой элементы из центра платы.
Однако Артем предположил, что число элементов в центре платы не уменьшается
на самом деле. Кольцо - чисто визуальный эффект, не соответствующий реальной
плотности расположения элементов. Просто там где кольцо, элементы еще "не решили",
в какой бин им лечь, поэтому там размещение слегка размазано. В центре же размещение
уже устоялось и минимизация длины проводов привела к тому, что все они аккуратно легли 
в центр платы. Это необходимо проверить!!

При более детальном изучении картинок с размещением на ibm14 и в предположении что Артем
прав, можно предположить, что губительность легализации связана не с тем, что элементы 
расположены кольцом, а с тем, что они расположены неравномерно. можно заметить, что в 
углах платы вообще нет элементов, а это более тревожный симптом. Значит, все-таки надо 
заставлять алгоритм выравнивать discrepancy.

Оптимизировал работу кластеризации. Основная идея - предвычисление размеров нетов в нетлисте,
для чего создал массив интов. !! Вроде работает правильно, но необходима проверка.
На сколько быстрее работать стало не засекал, вроде быстрее.

Наблюдение: если число бинов четное, тогда они не двигаются с места. Видимо это связано с тем,
что они лежат на перекрестии биновой сетки и эта точка является точкой равновесия. Я запрограммировал, 
чтобы это число было всегда нечетным.

ИТОГИ СУТОЧНОГО ИССЛЕДОВАНИЯ
теперь алгоритм дает 5% отставания от mPL на ibm01 и ibm14 без перекомпиляции,
будучи заряженным следующими параметрами:
1. очень важно
   Начальное значение мю (вес ограничений) надо делать меньше, чтобы провода держали тесно связанные кластеры 
   вместе. Другими словами, не надо слишком агрессивно размазывать кластеры, надо делать это аккуратно 
   (с оглядкой на log-sum-exp) – это Очень сильно влияет на качество размещения. В статьях про APlace пишут 
   про это, нам еще предстоит подобрать хорошее начальное значение мю.
   Кстати, мы по-прежнему не используем мю0, основанное на градиентах. Потому что с ним фигово, однако 
   как оказалось, изобретенный мной метод использовался в Aplace перед градиентным. Так что в приниципе, 
   можно работать и с ним. Но наверное, у них были основания в такому переходу, поэтому надо будет
   разобраться и с градиентом тоже.
   
2. очень важно
   Радиус потенциала = 2+эпсилон бина. Так они быстрее всего и равномернее всего расползаются.
   Насколько я понимаю, меньшая величина (1.1) приводит к "слепоте метода", он не видит совершенно пустые
   бины неподалеку от себя, поэтому не тащит туда кластеры. 3.1 наоборот, слишком много,
   видимо создается эффект псеводнаполненности бинов. Они хорошо расползаются, но углы платы
   и вообще периметр выглядит недозаполненным. Думаю это связано с тем, что пологость потенциала
   приводит к этому самому псевдонасыщению пустых бинов за счет кластеров даже довольно далеких бинов.
   
3. очень важно
   Предпочтительное число кластеров в одном бине = 10. Так кластеры равномернее всего заполняют плоскость платы.
   Здесь Артем оказался абсолютно прав, что нужно уменьшать размер кластеров, это в целом выравнивает размещение.
   Вопрос состоит в том, насколько мелкими стоит делать бины. Я попробовал сделать 1 бин на один кластер, 
   получилось плохо. Периметр снова оказался пустым. А с 10 получается вроде неплохо.
     
4. ускорение
   На ранних стадиях релаксации надо делать больше итераций по мю (позволять аккуратно расталкивать кластеры), 
   а на поздних – больше итераций внутри МСГ (элементы уже растолканы, надо найти хорошую точку). 
   Поэтому я сделал так что первый параметр равен 16*(2^-i), а второй 32*2^i. 
   В итоге мы сохраняем общее число МСГ на каждой итерации релаксации, но направляем их на нужную работу 
   (либо расталкивание, либо поиск лучшей точки в окрестности).
   Надо подобрать более адекватные значения чем эти 16 и 32, но вроде и с ними неплохо.

2008-03-03-artem
слишком много элементов улетает на терминалы, решил вернуть штраф за вылет за границу платы.
Результат сразу порадовал - 9% отставания на ibm01 вместо ранних 13.6%, однако время
работы оставляет желать лучшего (нужно искать компромисс между значениями параметров 
функции TaoSetTolerances и временем работы). Наблюдается интересная картинка:
на промежуточных стадиях МСГ элементы наполовину выглядывают за плату,
что дает серьезные основания полагать, что штраф работает правильно.
Сделал более точный штраф, он не позволяет даже выглядывания элементов.
Поставил макс. число итераций внутри МСГ 150, результат - 7.1% вместо 9%.
Уменьшение параметра сглаживания вдвое дало 5%.

Падение плэйсера на некоторых тестах было вызвано тем, что элементы
распределялись по плате крайне неравномерно. Легализация ожидает на вход более-менее
"хорошее" размещение, а тут полная чушь приходила. После подстройки
всё вроде работает гладко.

2008-02-01-kirill
эксперименты с бисекцией вместо кластеризации показали, что
последняя не виновата в большой длине соединений (на порядок больше)
уже на стадии кластеризации. Сейчас думаю, что вероятно это связано 
с начальным размещением, что приводит к тому, что кластеры расползаются
по своим радиальным направлениям.
Вообще действительно, элементы стоит расталкивать именно из точного 
центра, чтобы они расползались, держа друг друга. В противном случае
мы можем рвать их связи. Те определение направления движения должно
зависеть от топологических соседей.

Итак, на настоящий момент оба включенных критерия работают неплохо, 
сейчас МСГ считает уже сотую итерацию.
1. Очень важный момент: начинать надо из точного центра платы. То случайное 
стартовое размещение, которое мы использовали ранее недопустимо, поскольку
мы просто выкидывали решение в случайную точку пространства решений,
не оставляя шансов приблизиться к оптимуму. Поэтому он быстро попадал
в локальный минимум (раскидывание элементов по радиальным направлениям), 
и уже оттуда не выползал.
2. Была ошибка в вычислении градиента. Снова знаки. Уверен на 90%, что теперь он правилен.
Однако это уже не в первый раз ;-)
Замечание! если сейчас закоментировать длину проводов и их градиент, то 
размещение не сдвинется с места, потому что градиент штрафов будет равен 0, 
так как по всем направлениям плохо и градиенты в сумме дадут 0.
Включая LSE, мы разрешаем терминалам тянуть кластеры на себя, поэтому 
они начинают расползаться по правильным направлениям, а не кто-куда.

Интересная фишка: очень неудобно постоянно писать и стирать ключи в 
командной строке. Чтобы не стирать, я теперь просто ставлю + вместо -.
Полезный ключ -help, выводит на все другие ключи.

2008-02-21-kirill
снова нашел ошибку в потенциалах, это знак.
когда поправил, элементы перестали покидать пределы платы.
радиус потенциала очень важен. лучшее значение 0.6

очень странно, решатель не в состоянии идеально выровнять 
число кластеров в бинах. он выравнивает, но почему-то рано 
останавливается, написав про ошибку линейного поиска.
видимо надо разобраться почему может останавливаться
линейный поиск

еще как заметил артем, имеем очень большу длину проводов 
на стадии кластеризации. либо мы совсем не оптимизируем
LSE, хоть он и включен, либо кластеризация кривая, поэтому
хорошее размазывание автоматически дает очень плохую длину 
проводов.

NEXTSTEP
- узнать почему может стопориться линейный поиск (в указанном 
  направлении нет минимума, или даже меньшего значения). после
  понять причины у нас: расхождение функции с градиентом, что-то 
  другое
- просмотреть кластеризацию на предмет ошибок. вероятно стоит 
  использовать разбиение (!!!) вместо кластеризации.


2008-02-20-artem
GetDiscrepancy исправлена и учитывает положение кластеров более аккуратно.
В мануале Tao нашел функцию, к-ая возвращает много полезной информации
при работе решателя. В частности, используя текущее число проделанных итераций удалось
добиться, чтобы дамп скидывался не 50 раз, а только если результат отличен от результата
предыдущей итерации (то есть метод что-то сделал и iterations стало > 1).
Убрал ненужные теперь строчки #if 1 и #if 0
Раскомментировал штраф за вылет за грницы платы. Дело в том, что эти ограничения 
не нужны только в начале при малом мю, при возрастании мю криетрий LSE 
становится менее значимым и элементы улетают далеко-далеко.

2008-02-20-kirill
схлопывания всех элементов в кучу на различных уровнях кластеризации 
не происходит. скорее всего это означает, что CalcMu0 у нас работает 
правильно. следующим шагом нужно написать строгий критерий останова
и заставить решатель очень равномерно растащить элементы. После этого 
нужно будет снова проверить, не схлопывается ли результат обратно.

вчера поправили знаки в вычислениях потенциалов и их градиентов
очень похоже, что теперь ограничения работают правильно
сейчас основные проблемы связаны с "неправильным расписанием"
вероятно даже вычисление мю0 верное, только в APlace у них
while по discrepancy. А у нас критерий останова слабее, да
и disc считается неправильно, потому что относит кластер только
к одному бину

2008-02-14-kirill
имеется проблема с тем, что если включить одновременно критерий и ограничения, 
то все элементы вытягиваются в полосу из центра платы в правый верхний угол.
у меня есть подозрение, что если закомментировать критерий, то уже наблюдается 
некоторый перекос в сторону первого квадранта
1. увеличение числа итераций МСГ мало что меняет
2. сложил все элементы точно в центр платы, увеличил радиус потенциала до 1.1, 
чтобы он "доставал" до центров других бинов. В результате имею вытянутое 
расположение элементов из центра в левый нижний угол ;-) на след итерации
имею диагональ лево-низ -- право-верх. элементы тяготеют к прямой y=x, вероятно
где-нибудь одна из переменных используется 2 раза.

похоже проблема была связана с тем, что изначальное размещение было сдвинуто 
в правый верхний угол, соответственно элементы ползли туда активнее.
функция SetInitialState - там надо случайные числа использовать не от 0 до 1,
 а от -1 до 1.
еще надо разобраться с сигнумами в потенциале - пока что-то ничего от них 
не зависит. так ли?

2008-02-06-kirill
эксперименты с параметрами метода линейного поиска не помогли
также не помогла замена метода линейного поиска
но в чем причина плохого размазывания я выяснил - радиус потенциала был 
слишком мал. Просто МСГ не видел, куда же надо толкать элементы, чтобы 
минимизировать функционал. Я уменьшил желаемое число кластеров в бине,
тем самым увеличив число бинов и уменьшив их размеры. Чем больше бинов, 
тем больше работы для решателя, но тем лучший результат он должен выдавать - 
более равномерное размещение элементов по плате.
Надо теперь подобрать радиус потенциала относительно размеров бина. Пока лучшим считаю
0.6, чтобы элемент было видно в соседнем бине и туда тянуло. но вот чтобы тянуло сильно,
сильно увеличивать радиус нельзы, потому как элемент станет давать вклад в
потенциал соседнего бина и мы получим псевдоравномерное размещение.
NEXTSTEPS
- отладиться (проблема с new)
- включить log-sum-exp, поэкспериментировать
- подчистить и наметить пути доработки и исследований


2008-02-05-kirill
обнаружил проблему с тем, что при первых вычислениях градиента 
использовался инициализированный нулем оказывается коэфициент
масштабирования величины потенциала. из-за этого первые градиенты 
были раны нулю. а вообще ошибка незначительная.

оказалось, что "сползание элементов" в левый нижний угол не проблема,
потому что на второй и последующих итерациях многоуровнего алгоритма
элементы расползаются по плате. На последней стадии можно даже 
увидеть биновую сетку (без логсум экспа) - просто агоритму приходится
равномерно наполнять мелкие бины, что приводит к разрежению общей массы
и группированию в бинах.

имеется проблема (?) с тем, что плоскость платы заполняется все же неравномерно.
так, нижняя часть и левая часть остаются с малым числом элементов. А все большие, 
что характерно, уползают в верхний правый угол, иногда пересекая границу.
Непонятно, почем МСГ не в состоянии идеально раскатать элементы по плате, останавливаясь
с таким большим значении функции стоимости. либо слишком слабые критерии останова, 
которые слишком рано срабатывают, либо незначительная ошибка в градиенте, которая 
дает неплохое решение (они ведь расползаются), но все-таки "уводит" от глобального
минимума. Другими словами есть расхождение между функцией стоимости и градиентом. 
У меня, кстати сейчас так и есть - я штрафую нахождение вне платы. Может быть
это является причиной??

также имеется проблема с выделением памяти. при попытке легализации мы падаем на new для 28
ряда. вероятно стоит освободить память после глобальной оптимизации. хотя task manager не пишет, 
что плейсер захватил много памяти - всего 80 метров. короче надо посмотреть.


2008-02-01-kirill
продолжил эксперименты с одними штрафами. 
сейчас активно ограничение на вылет элементов за границы платы - штраф = k% от общего штрафа
обнаружил пару багов, но это не сильно улучшило ситуацию. Элементы тянутся в левый нижний угол, 
по всей видимости туда показывает градиент. Только вот почему - неясно
NEXTSTEP:
- понять, почему элементы "стекают" влево вниз

2008-01-18-kirill
экспериментирую только со штрафами вместо целевой функции. 
хочу добиться, чтобы кластеры расползлись в узлы биновой сетки
приписал сигнум в градиент, теперь кластеры расползаются в разные стороны, но похоже они
не остаются в пределах платы. Они выползают за границы, их потенциал становится равным нулю,
видны ли они для градиента - не знаю. А нужно, чтобы он тянул их к центрам бинов.

2008-01-17-kirill
проблемы с работой метода
если зафиксировать мю, он не расталкивает их как положено
либо линейный поиск слишком ленивый
либо потенциалы неправильные
наблюдалось расталкивание либо вдоль икса, либо в левый нижний угол, либо вообще не расталкивалось
предложения:
- можно вбить перевернутый параболоид
- заставить линейный поиск работать лучше