params:
{
    objective = "LSE";
    target_clock_cycle = 0.0;

    techname = "IWLS"; //default
    //techname = "NangateMapped"; //with technology mapping
    //techname = "Nangate";       //without technology mapping
    //techname = "ISPD";

    //def = "../../Benchmarks/IWLS_GP_r1511/IWLS_GP_007161_tv80.def";
    def = "../../Benchmarks/IWLS05/ac97_ctrl.def";
};

plotter:
{
    //enabled = true;
    windowHeight = 800;
    histogramWindowHeight = 300;
    histogramWindowWidth = 1200;
    autoRefreshStep = 10;
    //saveImages = true;
    saveMilestoneImages = true;
    embeedMilestones = true;
    //createVideo = true;
};

DesignFlow:
{
    //PRE-RUN SECTION
    SkipSpecialNets = true;
    SkipBrokenNets = true;

    //MACRO LOOP SECTION
    nMacroIterations = 0;
    //LoopRandomPlacement = true;
    //LoopGlobalPlacement = true;
    //LoopLR          = true;
    //LoopLegalization = true;
    //LoopDetailedPlacement = true;

    //STANDARD PLACEMENT SECTION
    //RandomPlacement = true;
    GlobalPlacement = true;
    //LR          = true;
    //Legalization = true;
    //DetailedPlacement = true;
    //HippocratePlacement = true;
    //LRSizing = true;

    //REPEATERS INSERTION SECTION
    //Buffering = true;
    New_Buffering = true;    
    //BufRandomPlacement = true;
    //BufGlobalPlacement = true;
    //BufLR          = true;
    //BufLegalization = true;
    //BufDetailedPlacement = true;

    //MISCELLANEOUS
    //DrawCongestionMap = true; //needs testing
    //FGRRouting = true;
};

MacroLoop:
{
    QAcriteria = "LHPWL";
    LSE:
    {
        Clustering:
        {
            useClusteringInformationFromFile  = false;
        };
    };
};

LSE:
{
  Clustering:
  {
    useClusteringInformationFromFile  = true;
    //deleteDuplicatingNets             = true;
  };

  GlobalPlacement:
  {
    useQAClass = true;
    earlyExit = true;
    nConvergedIterations = 2;
    nTolerantIterations = 3;
    
    placeToTheCenter = true;

    useLogSumExp = true;
    useSpreading = true;
    useUnidirectSpreading = true;  //used only with useSpreading = true 
    useBorderBounds = true;

    Weights:
    {
      sprInitialRatio = 0.1;
    };

    Plotting:
    {
      plotSolverState = true;
      plotWait        = 1;
      gradientScaling = 1000.0;
      saveTAOmilestones = true;
    };

    TAOOptions:
    {
      commandLine               = ""; //-tao_monitor
      nOuterIterations          = 100;  //100
      nInnerIterations          = 100;  //100
      frtol = 1.0e-14;
    };
    
    PQAT:
    {
      showPercents = false;
      numberOfColumns = 11;
      Columns = ["Objective", "ObHPWL", "ObSpr", "gHPWL", "gSpr", "HPWL", "LHPWL", "TNS", "LTNS", "WNS", "LWNS"];
    };
  };
};

DetailedPlacement:
{
    HorizontalSearch:
    {
        active = true;
        plotter: {enabled = false;};
    };

    GlobalSwap:
    {
        active = true;
        plotter: {enabled = false;};
    };

    VerticalSearch:
    {
        active = true;
        plotter: {enabled = false;};
    };

    useConstraints = false;
};

HippocratePlacement:
{
    //	SWAP = true;
    MOVE =  true;
    LOCALMOVE = true;
    COMPACT = true;
    CENTER = true;

    KamaevCheckConstraints = true;

    PathsInCriticalOrder = true;

    LogEveryIteration=true;
    FindOnlyInsideGaps = true; //COMPACT
};

Timing:
{
    SignalDirectionsUsed = 1; //rise\fall
    RCE:
    {
        LayersUsed = 3;//0 - lumped (=1 with simplified C extraction), 1 or 2, 3=Hippocrate
    };
};

CriticalPaths:
{
    countLogReportCriticalPaths = 0;  //set to -1 if you want to print all the critical paths
    countPlotCriticalPaths = 0;       //set to -1 if you want to plot all the critical paths
    plotWait = 1;
};

NetWeighting:
{
    useNetWeights = true;
    netWeightsImportFileName = "";
    netWeightsExportFileName = "";
    method = "APlace";
    //method = "SensitivityGuidedNetWeighting";
    normalize = false;

    APlace:
    {
        u    = 0.3;
        beta = 2.0;
        aggregationMethod = "sum";
    };
    SensitivityGuidedNetWeighting:
    {
        minWeight = 1.0;
        alpha     = 0.6;
        C         = 3227.0;
    };
};

Legalization:
{
    Abacus:
    {
        //usePlotter = true;
        plotterStep = 100;
        //useWeights = true;
        weightMultiplier = 1;
    };
};

Buffering:
{
    DefaultBuffer:
    {
        Macro="BUF_ITL";
        InputPin = "A";
        OutputPin = "Y";
    };
    Percent = 1.00;
    Iterations = 15;
    DoIterative = false;

    Legalization:
    {
        doReport = false;
    };
};

CongestionMap:
{
    nHorTiles  = 30;
    nVertTiles = 30;
    nMaxLines  = 10; //all wires
    nMaxCLines = 4; //critical wires
    nMaxPins   = 10;
};

FGRRouting:
{
    maxRoutingTime        = 86400; //max time to work in seconds
    calculateCapacity     = true;  //use (or not) formula to calculate capacity
    powerTracsPerRow      = 2;
    verticalCapacity      = 20;
    horizontalCapacity    = 20;
    nHorTiles             = 0; //if 0 then
    nVertTiles            = 0; //nHorTiles == nVertTiles == nRows / 2
    FGROutputFile         = "res.fgr";
    ImageSize             = 900; //horizontal and vertical number of pixels in the XPM file
    PrintToRoutersFormats = false;
    ISPDFileName          = "@params.def";
    LabyrinthFileName     = "@params.def";
};

Config:
{
    //Trace = true;
    Replicate = true;
    WarnOnChange = true;
};

New_Buffering:
{
    DefaultBuffer:
    {
        Macro="BUF_ITL";
        InputPin = "A";
        OutputPin = "Y";
    };
    UseOnlyDefaultBuffer = true;
    BufferList = "BUF_ITL,BUF_INVX1,BUF_INVX4,BUF_INVX8";
    TypePartition = 0; //0 - обычное линейное разбиение, 1 - динамическое распределение точек, //
                       //2 - легальное распределение точек (использовать только с 1 или 2 типом буферизации)
    IsInsertInSourceAndSink = true;
    BufferListLength = 4;
    Interval = 20;
    TypeBufferingAlgorithm = 1; //0 - рекурсивный обход дерева, 1 - линейный обход дерева, 
								//2 - линейный обход дерева и измененное вычисление длин ребер(TO DO: ѕ–»ƒ”ћј“№ Ќќ–ћјЋ№Ќ”ё ‘ќ–ћ”Ћ»–ќ¬ ”)
    Legalization:
    {
        doReport = false;
    };

    Plotting:
    {
        PlotSteinerPoint = false;
        PlotVGTree = false;
        PlotNets = false;
        PlotBuffer = false;
	    PlotBinGridValue = false;
        PlotterWaitTime = 1000;
    };

    Reporting:
    {
        reportParameters = false;
        reportBufferInfo = false;

        PrintNetInfo = false;
        PrintVGVariantsList = false;
    };
    
    MaxBufferCount = 0; //если равен 0 то нет ограничений на количество вставл€емых буферов,
    TypeModificationVanGinnekenList = 0; //0 - классические правила формировани€ и изменени€ списка вариантов,
                                         //1 - количество вставл€емых буферов ограничено MaxBufferCount
                                         //2 - полный перебор вариантов
    CountPinInBufferingNet = 0; //если равен 0 то нет ограничений
    IsTypeLimitationOnCountPinInBufferingNetEquality = true;
    NameBufferingNet = "";
    TypeBuferAddition = 0; //0 - оьычна€ вставка буферов, 1 - вставка с легализацией
    SizeBufferMultiplier = 1.0; //0.5313443074;//0.102;
    AdaptiveSizeBufferMultiplier = true;
    IsBufferingNetContainPrimaryPin = true;
    TotalAreaOfBuffersInRelationToAllCells = 1000.0; //0 - буферизаци€ без ограничени€, 1 - площадь буферов совпадает с площадью буферов
};