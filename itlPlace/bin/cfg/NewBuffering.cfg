params:
{
    objective = "LSE";
    target_clock_cycle = 0.0;

    techname = "IWLS"; //default
    //techname = "NangateMapped"; //with technology mapping
    //techname = "Nangate";       //without technology mapping
    //techname = "ISPD";

    //def = "../../Benchmarks/IWLS_GP_r1511/IWLS_GP_007161_tv80.def";
    //def = "../../Benchmarks/IWLS05/ac97_ctrl.def";
    def = "../../Benchmarks/IWLS05/tv80.def";
    //def = "../../Benchmarks/IWLS05/s298.def";
};

plotter:
{
    //enabled = true;
    windowHeight = 800;
    histogramWindowHeight = 300;
    histogramWindowWidth = 1200;
    autoRefreshStep = 10;
    saveImages = true;
    saveMilestoneImages = true;
    embeedMilestones = true;
    createVideo = true;
    pixDirectory = ".\\pix\\";
};

DesignFlow:
{
    //PRE-RUN SECTION
    SkipSpecialNets = true;
    SkipBrokenNets = true;

    //STANDARD PLACEMENT SECTION
    GlobalPlacement = true;
    //LR          = true;
    //Legalization = true;

    //REPEATERS INSERTION SECTION
    New_Buffering = true;
    //BufGlobalPlacement = true;
    //BufLR          = true;
    BufLegalization = true;
};


LSE:
{
    Clustering:
    {
        useClusteringInformationFromFile  = true;
        //deleteDuplicatingNets             = true;
    };

    GlobalPlacement:
    {    
        randSeed = 51117;
        batchSizeForvdExp = 1000;
        bufferName = "BUF_ITL";
        bufferCountUpperBound = 0.0; //set to 0 if you want to disable joint algorithm

        placeToTheCenter = true;
        shufflePercent = 0.0;

        useQAClass = true;
        QAcriteria = "LHPWL";
        earlyExit = true;
        improvementTreshold = -0.00; //-0.01 means 1% improvement decrease allowed
        nTolerantIterations = 3;
        nConvergedIterations = 2;

        useLogSumExp = true;
        useSumOfDelays = false;
        useLR = false;
        useSpreading = true;
        useUnidirectSpreading = true;  //used only with useSpreading = true 
        useBorderBounds = true;

        Weights:
        {
            lseInitialRatio = 1.0;
            lrInitialRatio = 1.0;
            sprInitialRatio = 0.1;

            lseDesiredRatio = 1.0;
            sprDesiredRatio = 1.1;

            lseUpdateMultiplier = 2.0;
            lrUpdateMultiplier = 2.0;
            sprUpdateMultiplier = 1.8;
        };

        alphaMultiplier = 0.5;
        potentialRatio = 2.1; //must be greater than 0.5

        LagrangianRelaxation:
        {
            muLR     = 0.5;

            theta    = 1.1;
            minFactor = 0.01;
            referenceValue = 100;

            Reporter:
            {
                verbose = false;
                plotMus = false;
                order = "CriticalPath"; //"Topological"
            };
        };

        TAOOptions:
        {
            commandLine               = ""; //-tao_monitor
            method                    = "tao_blmvm";
            nOuterIterations          = 100;
            nInnerIterations          = 100;

            fatol = 1.0e-14;
            frtol = 1.0e-14;
            catol = 1.0e-8;
            crtol = 1.0e-8;
        };

        Plotting:
        {
            plotWires = false;
            plotSolverState = false;
            saveTAOmilestones = false;
            plotWait        = 1;
            gradientScaling = 1000.0;
        };

        UseBuffering = true;
	    New_Buffering:
        {
            TypeNetListBuffering = 1; //0 - буферизация нетов входящих в все критические пути; 1 - PathBased

			SizeBufferMultiplier = 1.0; //0.5313443074;//0.102;
            AdaptiveSizeBufferMultiplier = true;
            IsNetContainPrimaryPin = true;
            TotalAllowableBuffersArea = 0; //0 - буферизация без ограничения, 1 - площадь буферов совпадает с площадью буферов
            ReRoutingSteinerTree = true;
            MaxCountRepeatNet = 0;
            LimitationCountCriticalPath = 4; //означает что будет произведено итераций буферизации не более чем CriticalPaths.Count() * LimitationCountCriticalPath, 0 - буферизуем до конца;
            NumberBufferedAtOnceCriticalPaths = 1;
            NumberMetaIterationStartBuffering = 0;//начиная с какой итерации кластеризации начнет работать буферизация в совместном алгоритме

            Plotting:
            {
                PlotSteinerPoint = false;
                PlotVGTree = false;
                PlotNets = false;
                PlotBuffer = false;
	            PlotBinGridValue = false;
                PlotterWaitTime = 1;
            };

            Reporting:
            {
                reportParameters = true;
                reportBufferInfo = false;

                PrintNetInfo = false;
                PrintVGVariantsList = false;
                PrintCriticalPathsInfo = false;
                PrintTimingAfterBufferingCriticalPaths = false;
                PrintSumPotencial = false;            
            };
        };
    	
	    PQAT:
	    {
		    showPercents = false;
		    Columns = ["Objective", "ObHPWL", "ObLR", "ObSpr", "gHPWL", "gLR", "gSpr", "HPWL", "LHPWL", "TNS", "LTNS", "WNS", "LWNS"];
	    };
    };
};

Timing:
{
    SignalDirectionsUsed = 1; //rise\fall
    RCE:
    {
        LayersUsed = 0;//0 - lumped (=1 with simplified C extraction), 1 or 2, 3=Hippocrate
    };
};

CriticalPaths:
{
    countLogReportCriticalPaths = 0;  //set to -1 if you want to print all the critical paths
    countPlotCriticalPaths = 0;       //set to -1 if you want to plot all the critical paths
    plotWait = 1;
};

Legalization:
{
    Abacus:
    {
        //usePlotter = true;
        plotterStep = 100;
        //useWeights = true;
        weightMultiplier = 1;
    };
};

New_Buffering:
{
    TypeNetListBuffering = 1; //0 - буферизация нетов входящих в все критические пути; 1 - PathBased

    ReRoutingSteinerTree = true;
    MaxCountRepeatNet = 0;
    LimitationCountCriticalPath = 4; //означает что будет произведено итераций буферизации не более чем CriticalPaths.Count() * LimitationCountCriticalPath, 0 - буферизуем до конца;
    NumberBufferedAtOnceCriticalPaths = 1;

    Plotting:
    {
        PlotSteinerPoint = false;
        PlotVGTree = false;
        PlotNets = false;
        PlotBuffer = false;
    };

    Reporting:
    {
        reportParameters = true;
        reportBufferInfo = false;

        PrintNetInfo = false;
        PrintVGVariantsList = false;
        PrintCriticalPathsInfo = false;
        PrintTimingAfterBufferingCriticalPaths = false;
        
    };
};